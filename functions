#!/bin/bash

###############################################################################################
##                                                                                           ##
##                    Universidad Carlos III de Madrid (UC3M), Spain                         ##
##       Commissariat à l'énergie atomique et aux énergies alternatives (CEA), France        ##
##                                                                                           ##
##    Lightning - The simple and lightweight network simulator based on Docker containers    ##
##                                                                                           ##
##    author:         Pablo Toribio (under supervision of professor C.J. Bernardos Cano,     ##
##                                   UC3M and professor A. Del Pozzo, CEA)                   ##
##                                                                                           ##
##    project site:   https://github.com/ptoribi/lightning                                   ##
##                                                                                           ##
##    file description:  library that provides several functions to be included and used     ##
##                       by the main program                                                 ##
##                                                                                           ##
###############################################################################################


# User-related variables
USER_BEHIND_SUDO=$(logname)
GROUP_OF_USER_BEHIND_SUDO=$(id -g -n $USER_BEHIND_SUDO)
# ptoribi: getent also works with remote authentication servers (LDAP, etc.)
# from "getent passwd" output: user:x:1000:1000:user,,,:/home/user:/bin/bash -> I extract the 6th field delimited by ":" (user's home path)
USER_BEHIND_SUDO_HOME_PATH=$(getent passwd $USER_BEHIND_SUDO | cut -d : -f 6)

# System-related variables
# ptoribi: "which" will find in the path the full location of the executable, "readlink -f" will resolve all possible symbolic links and "dirname" will remove the last component (file name).
LIGHTNING_INSTALLATION_PATH=$(dirname $(readlink -f $(which lightning)))
source $LIGHTNING_INSTALLATION_PATH/variables.conf
SCENARIOS_PATH=$LIGHTNING_INSTALLATION_PATH/scenarios
SCENARIOS_PATH_LOCAL=$LIGHTNING_INSTALLATION_PATH/scenarios-local
PATH_TO_XML=""
XSD_FILE=$LIGHTNING_INSTALLATION_PATH/lightning-xml-schema.xsd
#QUAGGA_CONFIG_FILES=$LIGHTNING_INSTALLATION_PATH/quagga-config-files
CONTAINERS_CREATED_FILE=$LIGHTNING_INSTALLATION_PATH/containers-created.log
NETWORKS_CREATED_FILE=$LIGHTNING_INSTALLATION_PATH/networks-created.log
LIGHTNING_GENERAL_LOG_FILE=$LIGHTNING_INSTALLATION_PATH/lightning.log
SECURITY_CAPABILITIES_FILE=$LIGHTNING_INSTALLATION_PATH/security/container_capabilities.conf
SECURITY_SUDO_COMMANDS_FILE=$LIGHTNING_INSTALLATION_PATH/security/sudo_commands.conf

# ptoribi: index of the arrays with information about the created containers
# -> will be used later when launching the terminal with the start process
# (after creating all the networks and performing all the connections)
ARRAY_INDEX=1
CONTAINER_NAME_ARRAY=""
CONTAINER_HOSTNAME_ARRAY=""
CONTAINER_USER_ARRAY=""
CONTAINER_TERMINAL_ARRAY=""
CONTAINER_START_ARRAY=""

# ptoribi: global variable that will indicate if a container was already created
# in that scenario
container_already_created=""

if [[ $SHARED_FOLDER_LOCATION == "TMP" ]]
then
  SHARED_FOLDER=/tmp/$USER_BEHIND_SUDO/$SHARED_FOLDER_NAME
else
  SHARED_FOLDER=$USER_BEHIND_SUDO_HOME_PATH/$SHARED_FOLDER_NAME
fi

# usage: version_header
# description: shows header displaying version number
version_header() {

  echo ""
  echo "      $(tput setaf 33)***************************************************$(tput sgr 0)"
  echo "      $(tput setaf 33)**$(tput setaf 45)    Universidad Carlos III de Madrid (UC3M)    $(tput setaf 33)**$(tput sgr 0)"
  echo "      $(tput setaf 33)**$(tput setaf 196)    Commissariat à l'énergie atomique et aux   $(tput setaf 33)**$(tput sgr 0)"
  echo "      $(tput setaf 33)**$(tput setaf 196)    énergies alternatives (CEA) - LIST/DILS    $(tput setaf 33)**$(tput sgr 0)"
  echo "      $(tput setaf 33)**$(tput setaf 255)              Lightning $(cat $LIGHTNING_INSTALLATION_PATH/version)                  $(tput setaf 33)**$(tput sgr 0)"
  echo "      $(tput setaf 33)***************************************************$(tput sgr 0)"
}

# usage: explore_scenarios
# description: explore all the directories in $SCENARIOS_PATH_LOCAL and $SCENARIOS_PATH listing all the available scenarios
# NOTE: this function only supports one directory depth level from $SCENARIOS_PATH_LOCAL and $SCENARIOS_PATH
explore_scenarios() {

  local NUMBER_DIRECTORIES
  local DIRECTORY_NAME

  list_scenarios_in_directory $SCENARIOS_PATH_LOCAL

  NUMBER_DIRECTORIES=$(ls -l $SCENARIOS_PATH_LOCAL | awk 'NR>1' | grep ^d | awk '{print $9}' | wc -l)
  for ((i=1; i<=$NUMBER_DIRECTORIES; i++))
  do
    DIRECTORY_NAME=$(ls -l $SCENARIOS_PATH_LOCAL | awk 'NR>1' | grep ^d | awk '{print $9}' | sed -n $i'p')
    list_scenarios_in_directory $SCENARIOS_PATH_LOCAL $DIRECTORY_NAME
  done

  list_scenarios_in_directory $SCENARIOS_PATH

  NUMBER_DIRECTORIES=$(ls -l $SCENARIOS_PATH | awk 'NR>1' | grep ^d | awk '{print $9}' | wc -l)
  for ((i=1; i<=$NUMBER_DIRECTORIES; i++))
  do
    DIRECTORY_NAME=$(ls -l $SCENARIOS_PATH | awk 'NR>1' | grep ^d | awk '{print $9}' | sed -n $i'p')
    list_scenarios_in_directory $SCENARIOS_PATH $DIRECTORY_NAME
  done
}

# usage: list_scenarios_in_directory PATH [DIRECTORY]
# description: list the available scenarios in the specified path or path+directory (XML or direct execution scenario files)
# example: list_scenarios_in_directory /usr/local/lightning/scenarios RYSCA
list_scenarios_in_directory() {

  local DIRECTORY=$1/$2

  local NUMBER_SCENARIOS_FILES
  local FILE_NAME           # name of the file, e.g.: scenario.xml
  local FILE_NAME_EXTENDED  # name of the file + relative path from $SCENARIOS_PATH, e.g.: SubjectName/LaboratorySession_1/scenario.xml
  local DESCRIPTION

  NUMBER_SCENARIOS_FILES=$(ls -l $DIRECTORY | awk 'NR>1' | grep -v ^d | awk '{print $9}' | grep -v .xsd | grep -v .pdf | grep -v .tmp | wc -l)
  if [[ $NUMBER_SCENARIOS_FILES -gt 0 ]]
  then
    echo "" # ptoribi: separator line between scenarios of different directory
  fi

  for ((j=1; j<=$NUMBER_SCENARIOS_FILES; j++))
  do
    FILE_NAME=$(ls -l $DIRECTORY | awk 'NR>1' | grep -v ^d | awk '{print $9}' | grep -v .xsd | grep -v .pdf | grep -v .tmp | sed -n $j'p')

    # ptoribi: if the file is an XML file
    if [[ $FILE_NAME == *.xml ]]
    then
      DESCRIPTION=$(xmllint --xpath 'string(/scenario/@description)' $DIRECTORY/$FILE_NAME)
    fi

    # ptoribi: if the file is a direct execution file (file without extension)
    if [[ $FILE_NAME != *.* ]]
    then
      # ptoribi: I use awk for taking all that is after "# DESCRIPTION:", and tail for removing the following space
      DESCRIPTION=$(grep "# DESCRIPTION:" $DIRECTORY/$FILE_NAME | awk -F '# DESCRIPTION:' '{print $2}' | tail -c +2)
      if [[ ${#DESCRIPTION} -eq 0 ]]
      then
        DESCRIPTION="[scenario description not available]"
      fi
    fi

    if [ "$#" -eq 2 ]
    then
      echo "  $(tput setaf 154) $2/${FILE_NAME%.*}$(tput sgr 0) - $(tput setaf 244)$DESCRIPTION $(tput sgr 0)"
    else
      echo "  $(tput setaf 154) ${FILE_NAME%.*}$(tput sgr 0) - $(tput setaf 244)$DESCRIPTION $(tput sgr 0)"
    fi
 done
}

# usage: usage_message
# description: shows usage message of the program and available scenarios
usage_message() {
  echo ""
  echo "$(tput setaf 220)[lightning]$(tput sgr 0) usage:"
  echo ""
  echo "  $(tput setaf 6)lightning                  $(tput sgr 0)-> display usage message and list available scenarios"
  echo "  $(tput setaf 6)lightning stop             $(tput sgr 0)-> close running scenario"
  echo "  $(tput setaf 6)lightning purge            $(tput sgr 0)-> ONLY use this option in case \"stop\" doesn't work"
  echo "  $(tput setaf 6)lightning start $(tput setaf 154)$(tput smul)SCENARIO$(tput rmul)   $(tput sgr 0)-> start selected network scenario"
  echo "  $(tput setaf 160)lightning update           $(tput sgr 0)-> update Lightning to the latest version available"
  echo ""
  echo "  Available scenarios:"
  #list_scenarios_in_directory $SCENARIOS_PATH
  explore_scenarios
  echo ""
  echo "  Your shared folder between host systems is located"
  echo "  at $(tput setaf 13)$SHARED_FOLDER$(tput sgr 0) in your main system, and will"
  echo "  be mounted as $(tput setaf 5)/home/$USER_BEHIND_SUDO$(tput sgr 0) inside the simulated host systems."
  echo ""
}


# description: disables ipv6 for one interface in the specified container (container should have been started in "privileged" mode)
# usage: disable_ipv6 CONTAINER_NAME INTERFACE_NAME
# example: disable_ipv6 pc1 eth1
#disable_ipv6() {
#
#  local CONTAINER_NAME=$1
#  local INTERFACE_NAME=$2
#
#  docker exec --privileged --user=root $CONTAINER_NAME sysctl -w net.ipv6.conf.$INTERFACE_NAME.disable_ipv6=1
#}


# description: clears all IP addresses present in the selected interface
# usage: clear_interface CONTAINER_NAME INTERFACE_NAME
# example: clear_interface pc1 eth1
clear_interface() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2

  docker exec --user=root $CONTAINER_NAME ip addr flush dev $INTERFACE_NAME
}


# description: creates a L2 network segment
# usage: create_network NET_NAME TYPE (max. NET_NAME length 15-3=12 characters)
# example: create_network net1 switch
create_network() {

  local NET_NAME=$1
  local TYPE=$2

  #if [[ -z $(ls -l /sys/class/net/ | awk 'NR>1' | awk '{print $9}' | grep -x $NET_NAME"_br") ]]
  # ptoribi: if the network doesn't exist yet, it will be created
  if [[ -z $(ls /sys/class/net/ | grep -x $NET_NAME"_br") ]]
  then
    local BRIDGE_NAME=$NET_NAME"_br"

    brctl addbr $BRIDGE_NAME
    ip link set dev $BRIDGE_NAME up

    # ptoribi: now FORWARD rule has to be allowed in iptables for that bridge
    iptables -A FORWARD -i $BRIDGE_NAME -j ACCEPT

    # ptoribi: add created network to NETWORKS_CREATED_FILE (it actually adds the bridge name)
    echo $BRIDGE_NAME >> $NETWORKS_CREATED_FILE

    information_message "Network segment $NET_NAME successfully created"
  else
      error_message "Network segment $NET_NAME already exists"
  fi

  if [ $TYPE == "hub" ]
  then
    brctl setageing $BRIDGE_NAME 0
  fi
}


# usage: create_interface CONTAINER_NAME INTERFACE_NAME [IP/SM]
# description: creates an ethernet interface in the specified container, optionally also configures an IP address
# example: create_interface h1 eth0 192.168.0.1/24
create_interface() {

  ### CREATE INTERFACE & PAIRS FOR THAT CONTAINER ###
  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2

  local INTERFACE_NAME_TO_BRIDGE=$CONTAINER_NAME"_"$INTERFACE_NAME
  ip netns exec $CONTAINER_NAME ip link add $INTERFACE_NAME type veth peer name $INTERFACE_NAME_TO_BRIDGE
  ip netns exec $CONTAINER_NAME ip link set $INTERFACE_NAME_TO_BRIDGE netns default
  ip netns exec $CONTAINER_NAME ip link set dev $INTERFACE_NAME up
  ip link set dev $INTERFACE_NAME_TO_BRIDGE up

  if [ "$#" -eq 3 ]; then
    # Assign IP to interface
    local IP_SM=$3
    configure_ip $CONTAINER_NAME $INTERFACE_NAME $IP_SM
  fi

  # Now both internal container interface and external are created, but not connected to any bridge
}


# usage: connect_machine CONTAINER_NAME INTERFACE_NAME NET_NAME [IP/SM]
# description: connects the specified interface to a network, optionally also configures an IP address
# requirements: the host and the net had to be already created
# example: connect_machine h1 eth0 net1 192.168.0.1/24
connect_machine() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2
  local NET_NAME=$3

  # NOTE: CONTAINER CONNECTS TO BRIDGE
  local BRIDGE_NAME=$NET_NAME"_br"
  local INTERFACE_NAME_TO_BRIDGE=$CONTAINER_NAME"_"$INTERFACE_NAME
  brctl addif $BRIDGE_NAME $INTERFACE_NAME_TO_BRIDGE
  ip link set dev $INTERFACE_NAME_TO_BRIDGE up

  if [ "$#" -eq 4 ]; then
    # Assign IP to interface
    local IP_SM=$4
    configure_ip $CONTAINER_NAME $INTERFACE_NAME $IP_SM
  fi

  information_message "Container $CONTAINER_NAME ($INTERFACE_NAME) successfully connected to $NET_NAME"
}


# usage: connect_machine_physical CONTAINER_NAME INTERFACE_NAME PHYSICAL_INTERFACE [IP/SM]
# description: connects the specified interface to a physical network interface of the host machine,
# there is no need to previously create an interface inside the container, this function will do it.
# using macvlan, optionally also configures an IP address
# example: connect_machine_physical r1 eth0.0 eth0 192.168.0.1/24
connect_machine_physical() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2
  local PHYSICAL_INTERFACE=$3

  # Check if PHYSICAL_INTERFACE is a physical NIC in the host system
  if [ -n $(ls -l /sys/class/net/ | awk 'NR>1' | grep -v virtual | awk '{print $9}' | grep -x $PHYSICAL_INTERFACE) ]
  then
    # NOTE: MACVLAN BRIDGE IS CREATED ON PHYSICAL INTERFACE
    # ptoribi: I use a temporal name for that macvlan interface *_tmp, so in case that it exist a physical network interface with the same  name in the host, it won't generate any problem
    ip link add $INTERFACE_NAME"_tmp" link $PHYSICAL_INTERFACE type macvlan mode bridge
    ip link set $INTERFACE_NAME"_tmp" netns $CONTAINER_NAME
    ip netns exec $CONTAINER_NAME ip link set $INTERFACE_NAME"_tmp" name $INTERFACE_NAME
    ip netns exec $CONTAINER_NAME ip link set dev $INTERFACE_NAME up

    if [ "$#" -eq 4 ]; then
      # Assign IP to interface
      local IP_SM=$4
      configure_ip $CONTAINER_NAME $INTERFACE_NAME $IP_SM
    fi
  else
    error_message "$PHYSICAL_INTERFACE is not a physical network interface of the host system"
  fi

  information_message "Container $CONTAINER_NAME ($INTERFACE_NAME) directly connected to physical interface $PHYSICAL_INTERFACE"
}


# NOTE: FUNCIÓN NO PROBADA !!!
# usage: disconnect_machine HOST_NAME INTERFACE_NAME NET_NAME
# description: disconnects the specified interface of a host from a network
# requirements: the net of that host had to be already connected to that network
# example: disconnect_machine h1 eth0 net1
disconnect_machine() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2
  local NET_NAME=$3
  local CONTAINER_PID=`docker inspect -f '{{.State.Pid}}' $CONTAINER_NAME`

  local BRIDGE_NAME=$NET_NAME"_br"
  local INTERFACE_NAME_TO_BRIDGE=$CONTAINER_NAME"_"$INTERFACE_NAME
  ip link set dev $INTERFACE_NAME_TO_BRIDGE down
  brctl delif $BRIDGE_NAME $INTERFACE_NAME_TO_BRIDGE

  information_message "Container $CONTAINER_NAME ($INTERFACE_NAME) successfully disconnected from $NET_NAME"
}


# usage: configure_ip CONTAINER_NAME INTERFACE_NAME IP/SM
# description: adds IPv4 or IPv6 adress to the desired interface
# example: configure_ip hostA eth1 192.168.0.1/24
# example: configure_ip hostA eth1 2001:0db8:0:f101::1/64
configure_ip() {

  local CONTAINER_NAME=$1
  local INTERFACE_NAME=$2
  local IP_SM=$3

  if [[ $IP_SM == *"."*"."*"."* ]]
  then
    # ptoribi: it is a IPv4 address
    ip netns exec $CONTAINER_NAME ip addr add $IP_SM dev $INTERFACE_NAME
  else
    # ptoribi: it is a IPv6 address
    ip netns exec $CONTAINER_NAME ip -6 addr add $IP_SM dev $INTERFACE_NAME
  fi
}


display_all_containers() {

  # ptoribi: display the xterm window of all containers
  local index=1

  while [[ ${#CONTAINER_NAME_ARRAY[$index]} -ne 0 ]]
  do
    if [[ "${CONTAINER_TERMINAL_ARRAY[index]}" == "xterm" ]]
    then
      xterm -T "${CONTAINER_HOSTNAME_ARRAY[index]}" -e "docker exec -i -t --user=${CONTAINER_USER_ARRAY[index]} ${CONTAINER_NAME_ARRAY[index]} ${CONTAINER_START_ARRAY[index]}" &
    fi

    ((index++))
  done
}

# usage: display_container CONTAINER_NAME CONTAINER_USER TERMINAL CONTAINER_START_COMMAND [WINDOW_TITLE]
# description: launches terminal window executing the start command for the container
# example: display_container h1 root xterm "sleep 300" host1
display_container() {

 local CONTAINER_NAME=$1
 local CONTAINER_USER=$2
 local TERMINAL_TYPE=$3
 local CONTAINER_START_COMMAND=$4

 echo ---${CONTAINER_START_ARRAY[1]}
 echo "$1" - "$1" - "$3" - "$4"

 if [ "$#" -ne 0 ]
 then
   local WINDOW_TITLE=$5
 else
   local WINDOW_TITLE=$1
 fi

  if [[ $TERMINAL_TYPE == "xterm" ]]
  then
    echo $CONTAINER_START_COMMAND
    echo xterm -T "$WINDOW_TITLE" -e "docker exec -i -t --user=$CONTAINER_USER $CONTAINER_NAME $CONTAINER_START_COMMAND" &
    xterm -T "$WINDOW_TITLE" -e "docker exec -i -t --user=$CONTAINER_USER $CONTAINER_NAME $CONTAINER_START_COMMAND" &
  fi
}

# usage: check_if_container_already_created CONTAINER_NAME
# description: checks if the specified container has already been created previously in the scenario
# and saves the result in the global variable container_already_created with a "yes" or a "no"
# example: check_if_container_already_created h1
check_if_container_already_created() {

  local container_name=$1
  local READEN_LINE=""
  container_already_created="no"

  if [ -e $CONTAINERS_CREATED_FILE ]
  then
    while read READEN_LINE; do
      if [ "$READEN_LINE" == "$container_name" ]
      then
        container_already_created="yes"
        break
      fi
    done < $CONTAINERS_CREATED_FILE
  fi
}


# usage: stop_containers
# description: reads from the log file where the name of started container are recorded and stops them one by one
# example: stop_containers
stop_containers() {

  if [ -e $CONTAINERS_CREATED_FILE ]
  then
    while :
    do
      local READEN_LINE=$(head -n 1 $CONTAINERS_CREATED_FILE)
      if [ -z "$READEN_LINE" ]
      then
        rm $CONTAINERS_CREATED_FILE
        if [ $? == 0 ]
        then
          success_message "Containers stopped!"
        fi
        break
      else
        #docker stop $READEN_LINE >> $LIGHTNING_GENERAL_LOG_FILE
        docker kill $READEN_LINE >> $LIGHTNING_GENERAL_LOG_FILE
        if [ $? == 0 ]
        then
          information_message "Container $READEN_LINE successfully stopped"
        fi
        sed -i '1d' $CONTAINERS_CREATED_FILE
      fi
    done
  else
    error_message "$CONTAINERS_CREATED_FILE not found!"
  fi
}


# usage: delete_networks
# description: reads from the log file where the name of created networks are recorded and deletes them one by one
# example: delete_networks
delete_networks() {

  if [ -e $NETWORKS_CREATED_FILE ]
  then
    while :
    do
      local READEN_LINE=$(head -n 1 $NETWORKS_CREATED_FILE)
      if [ -z "$READEN_LINE" ]
      then
        rm $NETWORKS_CREATED_FILE
        if [ $? == 0 ]
        then
          success_message "Networks destroyed!"
        fi
        break
      else
        ip link set $READEN_LINE down
        if [ $? == 0 ]
        then
          brctl delbr $READEN_LINE
          if [ $? == 0 ]
          then
            information_message "Bridge $READEN_LINE successfully deleted"
          else
            error_message "Error when deleting bridge $READEN_LINE"
          fi
        else
          error_message "Error when setting down bridge $READEN_LINE"
        fi
        sed -i '1d' $NETWORKS_CREATED_FILE
      fi
    done
  else
    error_message "$NETWORKS_CREATED_FILE not found!"
  fi
}


# usage: error_message MESSAGE
# description: displays the specified text in black with red background
error_message() {
  echo $(tput setaf 220)[lightning]:$(tput sgr 0) $(tput setaf 0)$(tput setab 1) $1 $(tput sgr 0)
}

# usage: information_message MESSAGE
# description: displays the specified text in green
information_message() {
  echo $(tput setaf 220)[lightning]:$(tput sgr 0) $(tput setaf 2) $1 $(tput sgr 0)
}

# usage: success_message MESSAGE
# description: displays the specified text in black with green background
success_message() {
  echo $(tput setaf 220)[lightning]:$(tput sgr 0) $(tput setaf 0)$(tput setab 2) $1 $(tput sgr 0)
}


# usage: lightning_stop
# description: executes stop_containers and delete_networks and sfter that deletes both log files
# example: lightning_stop
lightning_stop() {
  if [ -e $CONTAINERS_CREATED_FILE ] && [ -e $NETWORKS_CREATED_FILE ]
  then
    stop_containers
    delete_networks
    success_message "Scenario successfully stopped"
  elif [ -e $CONTAINERS_CREATED_FILE ]
  then
    stop_containers
    success_message "Scenario successfully stopped"
  elif [ -e $NETWORKS_CREATED_FILE ]
  then
    delete_networks
    success_message "Scenario successfully stopped"
  else
    error_message "There is currently no scenario running to be stopped"
  fi
}


# usage: lightning_purge
# description: use with caution!, stops all the containers running in the host system and deletes
# all bridges whose name ends with "_br"
# example: lightning_purge
lightning_purge() {

  # ptoribi: stop all Docker container running on this system (and what if other containers not related to lightning are also running?, we do not care about the rest of this world)
  if [ -n "$(docker container ls -a -q)" ]
  then
    docker stop $(docker container ls -a -q) >> $LIGHTNING_GENERAL_LOG_FILE
  fi

  # ptoribi: set down and destroy all bridges whose name ends with "_br" (this is the bridge name convention used by lightning)
  while :
  do
    # ptoribi: next line is based on jil's response (https://stackoverflow.com/questions/36960003/how-to-extract-bridge-name-from-brctl-output-with-bash). Thanks jil!
    # Explanation:
    # NOTE: "record" is the same as "line" in the awk man entry
    # {print $1} will print only the first field of each line
    # NR>1 will remove the first line of the "brctl show" output, that is a header (not interesting for us as it hasn't info)
    # NF>1 will print only records that have more that one field (when one bridge has multiple interfaces attached, each one appear in one separated line, we do not care about interfaces, only about bridge names)
    NEXT_BRIDGE=$(brctl show | awk 'NF>1 && NR>1 {print $1}' | grep _br | head -n 1)
    if [ -z "$NEXT_BRIDGE" ]
    then
      break
    else
      ip link set $NEXT_BRIDGE down
      brctl delbr $NEXT_BRIDGE
    fi
  done

  # ptoribi: remove CONTAINERS_CREATED_FILE and NETWORKS_CREATED_FILE files
  rm -f $CONTAINERS_CREATED_FILE
  rm -f $NETWORKS_CREATED_FILE

  success_message "System successfully purged"
}


# usage: read_xml XML_FILE
# description: reads an XML scenario file and creates containers, networks and connections accordingly
# example: read_xml /usr/local/lightning/scenarios/RYSCA/simple_con_router.xml
read_xml() {

  local XML_FILE=$1

  # ptoribi: first of all, validation. Lightning will not process XML files that do not comply with the Lightning XML Schema.
  #xmllint --schema $XSD_FILE $XML_FILE --noout >> $LIGHTNING_GENERAL_LOG_FILE
  #if [ $? == 0 ]
  #then
    read_capabilities
    read_sudo_commands
    read_types $XML_FILE
    read_networks $XML_FILE
    display_all_containers

    success_message "Scenario successfully launched"
  #else
    #error_message "$XML_FILE validation error, the file does not comply with the Lightning XML Schema"
  #fi
}

# usage: read_capabilities
# description: reads the security capabilities stored in SECURITY_CAPABILITIES_FILE and loads them in the global variable CAP_ADD_CHAIN_LIST
read_capabilities() {
  local line_number
  local READEN_LINE
  local CAPABILITY
  # ptoribi: the variable CAP_ADD_CHAIN_LIST will have the form "--cap-add=CAP1 --cap-add=CAP2 --cap-add=CAP3 ..."
  CAP_ADD_CHAIN_LIST=""

  # ptoribi: populate CAP_ADD_CHAIN_LIST variable with the uncommented capabilities of the file SECURITY_CAPABILITIES_FILE
  line_number=1
  if [ -e $SECURITY_CAPABILITIES_FILE ]
  then
    while :
    do
      # ptoribi: I read the nth line of the file
      READEN_LINE=$(sed -n ${line_number}p $SECURITY_CAPABILITIES_FILE)
      if [ -z "$READEN_LINE" ]
      then
        break
      else
        if [[ $(echo $READEN_LINE | grep -v ^\#) > 0 ]]
        then
          # ptoribi: line does not start by #, so it is a line containing a capability
          # I take the first word of the line, which is actually the capability
          CAPABILITY=$(echo $READEN_LINE | awk '{print $1}')
          CAP_ADD_CHAIN_LIST=$CAP_ADD_CHAIN_LIST"--cap-add="$CAPABILITY" "
          #echo "Capability:" $CAPABILITY
        fi
        # ptoribi: in bash we use $((...)) for arithmetic expressions
        # line_number is increased in 1
        line_number=$((line_number+1))
      fi
    done
  else
    error_message "$SECURITY_CAPABILITIES_FILE not found!"
  fi
}

# usage: read_sudo_commands
# description: reads the allowed sudo commands stored in SECURITY_SUDO_COMMANDS_FILE and loads them in the global variable SUDO_COMMANDS_CHAIN_LIST
read_sudo_commands() {
  local line_number
  local READEN_LINE
  local SUDO_COMMAND
  # ptoribi: the variable CAP_ADD_CHAIN_LIST will have the form "--cap-add=CAP1 --cap-add=CAP2 --cap-add=CAP3 ..."
  SUDO_COMMANDS_CHAIN_LIST=""

  # ptoribi: populate SUDO_COMMANDS_CHAIN_LIST variable with the uncommented capabilities of the file SECURITY_SUDO_COMMANDS_FILE
  line_number=1
  if [ -e $SECURITY_SUDO_COMMANDS_FILE ]
  then
    while :
    do
      # ptoribi: I read the nth line of the file
      READEN_LINE=$(sed -n ${line_number}p $SECURITY_SUDO_COMMANDS_FILE)
      if [ -z "$READEN_LINE" ]
      then
        break
      else
        if [[ $(echo $READEN_LINE | grep -v ^\#) > 0 ]]
        then
          # ptoribi: line does not start by #, so it is a line containing a capability
          # I take the first word of the line, which is actually the command
          SUDO_COMMAND=$(echo $READEN_LINE | awk '{print $1}')
          if [[ first_command_readen -eq 0 ]]
          then
            # ptoribi: if it is the first command of the list
            SUDO_COMMANDS_CHAIN_LIST=$SUDO_COMMAND
            first_command_readen=1
          else
            # ptoribi: if it is the n>1 command of the list
            SUDO_COMMANDS_CHAIN_LIST=$SUDO_COMMANDS_CHAIN_LIST", "$SUDO_COMMAND
          fi
          #echo "Sudo Command:" $SUDO_COMMAND
        fi
        # ptoribi: in bash we use $((...)) for arithmetic expressions
        # line_number is increased in 1
        line_number=$((line_number+1))
      fi
    done
  else
    error_message "$SECURITY_SUDO_COMMANDS_FILE not found!"
  fi
}


# usage: ainer CONTAINER_NAME CONTAINER_HOSTNAME CONTAINER_TYPE
# description: creates a container of type TYPE with no network interfaces
# example: create_container h1 host1 host
create_container() {
  local CONTAINER_NAME=$1
  local CONTAINER_HOSTNAME=$2
  local TYPE=$3

  # ptoribi: indexes for retrieving value of variables
  TYPE_INTERFACE_INDEX=1
  TYPE_INTERFACE_DEFAULT_IP_INDEX=1
  TYPE_COPY_INDEX=1
  TYPE_SETUP_INDEX=1

  # 1.- CREATE CONTAINER
  local TYPE_name=$(tmp=XML_${TYPE}_name && echo ${!tmp})
  if [[ ${#TYPE_name} -ne 0 && $TYPE -eq $TYPE_name ]]
  then
    local TYPE_image=$(tmp=XML_${TYPE}_image && echo ${!tmp})
    local TYPE_enable_ipv6=$(tmp=XML_${TYPE}_enable_ipv6 && echo ${!tmp})
    local TYPE_shared_folder=$(tmp=XML_${TYPE}_shared_folder && echo ${!tmp})
    local TYPE_graphics=$(tmp=XML_${TYPE}_graphics && echo ${!tmp})
    local TYPE_user=$(tmp=XML_${TYPE}_user && echo ${!tmp}) # ptoribi: also used for executing the start command
    local TYPE_terminal=$(tmp=XML_${TYPE}_terminal && echo ${!tmp}) # ptoribi: also used for executing the start command
    local TYPE_start=$(tmp=XML_${TYPE}_start && echo ${!tmp})

    # ptoribi: example
    #docker run -t -d --rm --name=$NAME --hostname=$HOSTNAME --net=none --sysctl net.ipv6.conf.all.disable_ipv6=0 \
    #-e DISPLAY=unix$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix -v $SHARED_FOLDER:/home/$USER_BEHIND_SUDO --cap-drop=ALL \
    #$CAP_ADD_CHAIN_LIST $DOCKER_IMAGE_host >> $LIGHTNING_GENERAL_LOG_FILE

    # ptoribi: basic info about the container, as the name or the hostname
    # --rm means the container will be destroyed when stopped, no need to make "docker rm $ROUTER_NAME" after stop
    local DOCKER_COMMAND="docker run -t -d --rm --name=$CONTAINER_NAME --hostname=$CONTAINER_HOSTNAME --net=none "

    # ptoribi: support for IPv6 (all the network interfaces)
    if [[ "$TYPE_enable_ipv6" == "yes" ]]
    then
      DOCKER_COMMAND=$DOCKER_COMMAND"--sysctl net.ipv6.conf.all.disable_ipv6=0 --sysctl net.ipv6.conf.all.forwarding=1 "
    fi

    #echo $TYPE_graphics
    # ptoribi: support for graphis forwarding from the container to the host
    if [ "$TYPE_graphics" == "xorg" ]
    then
      DOCKER_COMMAND=$DOCKER_COMMAND"-e DISPLAY=unix$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix "
    elif [[ "$TYPE_graphics" == "wayland" ]]
    then
      #TO-DO
      echo $TYPE_graphics
      echo "WAYLAND SUPPORT NOT IMPLEMENTED YET"
    fi

    # ptoribi: support for shared folder between container and host OS
    if [[ "$TYPE_shared_folder" == "yes" && "$TYPE_user" == "root" ]]
    then
      DOCKER_COMMAND=$DOCKER_COMMAND"-v $SHARED_FOLDER:/root "
    elif [[ "$TYPE_shared_folder" == "yes" && "$TYPE_user" == "same" ]]
    then
      DOCKER_COMMAND=$DOCKER_COMMAND"-v $SHARED_FOLDER:/home/$USER_BEHIND_SUDO "
    fi

    # ptoribi: security capabilities
    # with "--cap-drop=ALL" I will drop all capabilities in order to have full control by adding one by one
    # the capabilities present in the file SECURITY_SUDO_COMMANDS_FILE will the only ones added to the containers
    #DOCKER_COMMAND=$DOCKER_COMMAND"--cap-drop=ALL $CAP_ADD_CHAIN_LIST $TYPE_image >> $LIGHTNING_GENERAL_LOG_FILE"
    DOCKER_COMMAND=$DOCKER_COMMAND"--cap-drop=ALL $CAP_ADD_CHAIN_LIST $TYPE_image"

    # ptoribi: execute the command and run the container
    $DOCKER_COMMAND >> $LIGHTNING_GENERAL_LOG_FILE

    if [[ "$TYPE_user" == "same" ]]
    then
      TYPE_user=$USER_BEHIND_SUDO
      # ptoribi: create user inside the container with same uid:gid as the one executing this program
      docker exec --user=root $CONTAINER_NAME groupadd --gid $(id -g $GROUP_OF_USER_BEHIND_SUDO) $GROUP_OF_USER_BEHIND_SUDO >> $LIGHTNING_GENERAL_LOG_FILE
      docker exec --user=root $CONTAINER_NAME useradd -M --uid $(id -u $USER_BEHIND_SUDO) --gid $(id -g $GROUP_OF_USER_BEHIND_SUDO) $USER_BEHIND_SUDO >> $LIGHTNING_GENERAL_LOG_FILE

      # ptoribi: add that user to the sudoers file specifying the commands that can execute
      docker exec --user=root $CONTAINER_NAME bash -c "echo \#Added by Lightning: >> /etc/sudoers" >> $LIGHTNING_GENERAL_LOG_FILE
      docker exec --user=root $CONTAINER_NAME bash -c "echo $USER_BEHIND_SUDO ALL=\(ALL\) NOPASSWD: $SUDO_COMMANDS_CHAIN_LIST >> /etc/sudoers" >> $LIGHTNING_GENERAL_LOG_FILE

      # ptoribi: for working properly, sudo needs the following files populated:
      # /etc/hostname
      #   $CONTAINER_HOSTNAME
      # /etc/hosts
      #   127.0.0.1   localhost
      #   127.0.1.1   $CONTAINER_HOSTNAME
      docker exec --user=root $CONTAINER_NAME bash -c "echo \#Added by Lightning: >> /etc/hosts" >> $LIGHTNING_GENERAL_LOG_FILE
      docker exec --user=root $CONTAINER_NAME bash -c "echo 127.0.1.1 $CONTAINER_HOSTNAME >> /etc/hosts" >> $LIGHTNING_GENERAL_LOG_FILE
    fi

    if [[ "$TYPE_graphics" == "xorg" ]]
    then
      # ptoribi: allows the container to make connections to the X-org server running in the main OS
      xhost +local:`docker inspect --format='{{ .Config.Hostname }}' $CONTAINER_NAME` >> $LIGHTNING_GENERAL_LOG_FILE
    elif [[ "$TYPE_graphics" == "wayland" ]]
    then
      #TO-DO
      echo "WAYLAND SUPPORT NOT IMPLEMENTED YET"
    fi

    # ptoribi: create links for accessing the network namespace
    local CONTAINER_PID=`docker inspect -f '{{.State.Pid}}' $CONTAINER_NAME`
    mkdir -p /var/run/netns
    ln -sf /proc/1/ns/net /var/run/netns/default
    ln -sf /proc/$CONTAINER_PID/ns/net /var/run/netns/$CONTAINER_NAME

    # 2.- CREATE NETWORK INTERFACES OF THE CONTAINER AND CONFIGURE THEM
    local TYPE_INTERFACE_name=$(tmp=XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_name && echo ${!tmp})
    while [[ ${#TYPE_INTERFACE_name} -ne 0 ]]
    do
      local TYPE_INTERFACE_link_local_ipv6=$(tmp=XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_link_local_ipv6 && echo ${!tmp})
      local TYPE_INTERFACE_connected_to_physical_interface=$(tmp=XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_connected_to_physical_interface && echo ${!tmp})

      if [[ ${#TYPE_INTERFACE_connected_to_physical_interface} -ne 0 ]]
      then
        connect_machine_physical $CONTAINER_NAME $TYPE_INTERFACE_name $TYPE_INTERFACE_connected_to_physical_interface
      else
        create_interface $CONTAINER_NAME $TYPE_INTERFACE_name
      fi

      if [ $TYPE_enable_ipv6 == "yes" ] && [ $TYPE_INTERFACE_link_local_ipv6 == "no" ]
      then
        clear_interface $CONTAINER_NAME $TYPE_INTERFACE_name
      fi

      # 3.- CONFIGURE DEFAULT IP ADDRESSES ON THE INTERFACE
      local TYPE_INTERFACE_DEFAULT_IP=$(tmp=XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_default_ip${TYPE_INTERFACE_DEFAULT_IP_INDEX} && echo ${!tmp})
      while [[ ${#TYPE_INTERFACE_DEFAULT_IP} -ne 0 ]]
      do
        configure_ip $CONTAINER_NAME $TYPE_INTERFACE_name $TYPE_INTERFACE_DEFAULT_IP

        ((TYPE_INTERFACE_DEFAULT_IP_INDEX++))
        TYPE_INTERFACE_DEFAULT_IP=$(tmp=XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_default_ip${TYPE_INTERFACE_DEFAULT_IP_INDEX} && echo ${!tmp})
      done

      ((TYPE_INTERFACE_INDEX++))
      TYPE_INTERFACE_name=$(tmp=XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_name && echo ${!tmp})
    done

    # 4.- COPY ARTIFACTS INTO THE CONTAINER
    local TYPE_COPY_source=$(tmp=XML_${TYPE}_copy${TYPE_COPY_INDEX}_source && echo ${!tmp})
    local TYPE_COPY_destination=$(tmp=XML_${TYPE}_copy${TYPE_COPY_INDEX}_destination && echo ${!tmp})
    while [[ ${#TYPE_COPY_source} -ne 0 && ${#TYPE_COPY_destination} -ne 0 ]]
    do
      docker cp $PATH_TO_XML/$TYPE_COPY_source $CONTAINER_NAME:$TYPE_COPY_destination >> $LIGHTNING_GENERAL_LOG_FILE

      ((TYPE_COPY_INDEX++))
      TYPE_COPY_source=$(tmp=XML_${TYPE}_copy${TYPE_COPY_INDEX}_source && echo ${!tmp})
      TYPE_COPY_destination=$(tmp=XML_${TYPE}_copy${TYPE_COPY_INDEX}_destination && echo ${!tmp})
    done

    # 5.- EXECUTE SETUP CONFIGURATION COMMANDS INSIDE THE CONTAINER
    local TYPE_SETUP=$(tmp=XML_${TYPE}_setup${TYPE_SETUP_INDEX} && echo ${!tmp})
    while [[ ${#TYPE_SETUP} -ne 0 ]]
    do
      docker exec --user=root $CONTAINER_NAME bash -c "$TYPE_SETUP" >> $LIGHTNING_GENERAL_LOG_FILE

      ((TYPE_SETUP_INDEX++))
      TYPE_SETUP=$(tmp=XML_${TYPE}_setup${TYPE_SETUP_INDEX} && echo ${!tmp})
    done

    information_message "Container $CONTAINER_NAME (PID=$CONTAINER_PID) successfully created"

    # ptoribi: I populate these three arrays with the name of the container, hostname, etc.
    # the purpose of this is to store the info about the containers in order to display the
    # terminal window only after all they have been properly initialized and connected
    CONTAINER_NAME_ARRAY[$ARRAY_INDEX]=$CONTAINER_NAME
    CONTAINER_HOSTNAME_ARRAY[$ARRAY_INDEX]=$CONTAINER_HOSTNAME
    CONTAINER_USER_ARRAY[$ARRAY_INDEX]=$TYPE_user
    CONTAINER_TERMINAL_ARRAY[$ARRAY_INDEX]=$TYPE_terminal
    CONTAINER_START_ARRAY[$ARRAY_INDEX]=$TYPE_start
    ((ARRAY_INDEX++))

    # ptoribi: add created container to CONTAINERS_CREATED_FILE
    echo $CONTAINER_NAME >> $CONTAINERS_CREATED_FILE

    # 6.- EXECUTE START COMMAND AND SHOW TERMINAL WINDOW -> ALL AT THE END
  else
    error_message "The container type \"$TYPE\" has not been defined in the XML file, you must define it with <type> before using it"
  fi
}


# usage: read_types XML_FILE
# description: reads an XML scenario file and loads the defined types in global variables
# example: read_types /usr/local/lightning/scenarios/RYSCA/simple_con_router.xml
read_types() {

  local XML_FILE=$1

  # ptoribi: variables and indexes for reading the XML file
  local TYPE=""
  local TYPE_INDEX=1

  local TYPE_INTERFACE=""
  local TYPE_INTERFACE_INDEX=1

  local TYPE_INTERFACE_DEFAULT_IP=""
  local TYPE_INTERFACE_DEFAULT_IP_INDEX=1

  local TYPE_COPY_SOURCE=""
  local TYPE_COPY_DESTINATION=""
  local TYPE_COPY_INDEX=1

  local TYPE_SETUP=""
  local TYPE_SETUP_INDEX=1

  local TYPE_START=""
  # ptoribi: TYPE_START has no index because start command is unique

  local tmp_var # ptoribi: auxiliar variable for storing temporal values

    # ptoribi: READ TYPES
    TYPE_INDEX=1
    TYPE=$(xmllint --xpath 'string(/scenario/type['$TYPE_INDEX']/@name)' $XML_FILE)
    while [[ ${#TYPE} -ne 0 ]]
    do
      eval XML_${TYPE}_name=$TYPE
      eval XML_${TYPE}_image=$(xmllint --xpath 'string(/scenario/type['$TYPE_INDEX']/@image)' $XML_FILE)
      eval XML_${TYPE}_enable_ipv6=$(xmllint --xpath 'string(/scenario/type['$TYPE_INDEX']/@enable_ipv6)' $XML_FILE)
      eval XML_${TYPE}_shared_folder=$(xmllint --xpath 'string(/scenario/type['$TYPE_INDEX']/@shared_folder)' $XML_FILE)
      eval XML_${TYPE}_graphics=$(xmllint --xpath 'string(/scenario/type['$TYPE_INDEX']/@graphics)' $XML_FILE)
      eval XML_${TYPE}_user=$(xmllint --xpath 'string(/scenario/type['$TYPE_INDEX']/@user)' $XML_FILE)
      eval XML_${TYPE}_terminal=$(xmllint --xpath 'string(/scenario/type['$TYPE_INDEX']/@terminal)' $XML_FILE)
      eval XML_${TYPE}_start=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/start/command)' $XML_FILE)

      # ptoribi: APPLY DEFAULT VALUES CHECK CORRECTNESS OF BOUNDED ATTRIBUTES AND COMPULSORY ATTRIBUTES BEFORE PROCEEDING
      tmp_var=$(tmp=XML_${TYPE}_enable_ipv6 && echo ${!tmp})
      if [[ ${#tmp_var} -eq 0 ]]; then eval XML_${TYPE}_enable_ipv6="yes"; fi    # ptoribi: DEFAULT VALUE enable_ipv6="yes"
      tmp_var=$(tmp=XML_${TYPE}_shared_folder && echo ${!tmp})
      if [[ ${#tmp_var} -eq 0 ]]; then eval XML_${TYPE}_shared_folder="no"; fi   # ptoribi: DEFAULT VALUE shared_folder="no"
      tmp_var=$(tmp=XML_${TYPE}_graphics && echo ${!tmp})
      if [[ ${#tmp_var} -eq 0 ]]; then eval XML_${TYPE}_graphics="none"; fi      # ptoribi: DEFAULT VALUE graphics="none"
      tmp_var=$(tmp=XML_${TYPE}_user && echo ${!tmp})
      if [[ ${#tmp_var} -eq 0 ]]; then eval XML_${TYPE}_user="root"; fi          # ptoribi: DEFAULT VALUE user="root"
      tmp_var=$(tmp=XML_${TYPE}_terminal && echo ${!tmp})
      if [[ ${#tmp_var} -eq 0 ]]; then eval XML_${TYPE}_terminal="xterm"; fi     # ptoribi: DEFAULT VALUE terminal="xterm"
      tmp_var=$(tmp=XML_${TYPE}_start && echo ${!tmp})
      if [[ ${#tmp_var} -eq 0 ]]; then eval XML_${TYPE}_start="bash"; fi         # ptoribi: DEFAULT VALUE start="bash"

      # ptoribi: READ INTERFACES FOR THAT TYPE
      TYPE_INTERFACE_INDEX=1
      TYPE_INTERFACE=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/interface['$TYPE_INTERFACE_INDEX']/@name)' $XML_FILE)
      while [[ ${#TYPE_INTERFACE} -ne 0 ]]
      do
        eval XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_name=$TYPE_INTERFACE
        eval XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_link_local_ipv6=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/interface['$TYPE_INTERFACE_INDEX']/@link_local_ipv6)' $XML_FILE)
        eval XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_connected_to_physical_interface=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/interface['$TYPE_INTERFACE_INDEX']/@connected_to_physical_interface)' $XML_FILE)

        # ptoribi: APPLY DEFAULT VALUES CHECK CORRECTNESS OF BOUNDED ATTRIBUTES AND COMPULSORY ATTRIBUTES BEFORE PROCEEDING
        tmp_var=$(tmp=XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_link_local_ipv6 && echo ${!tmp})
        if [[ ${#tmp_var} -eq 0 ]]; then eval XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_link_local_ipv6="no"; fi                    # ptoribi: DEFAULT VALUE link_local_ipv6="no"
        #tmp_var=$(tmp=XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_connected_to_physical_interface && echo ${!tmp})                    # ptoribi: DEFAULT VALUE connected_to_physical_interface=""

        # ptoribi: READ DEFAULT IPS FOR THAT INTERFACE
        TYPE_INTERFACE_DEFAULT_IP_INDEX=1
        TYPE_INTERFACE_DEFAULT_IP=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/interface[./@name="'"$TYPE_INTERFACE"'"]/default_ip['$TYPE_INTERFACE_DEFAULT_IP_INDEX'])' $XML_FILE)
        while [[ ${#TYPE_INTERFACE_DEFAULT_IP} -ne 0 ]]
        do
          eval XML_${TYPE}_interface${TYPE_INTERFACE_INDEX}_default_ip${TYPE_INTERFACE_DEFAULT_IP_INDEX}=$TYPE_INTERFACE_DEFAULT_IP

          ((TYPE_INTERFACE_DEFAULT_IP_INDEX++))
          TYPE_INTERFACE_DEFAULT_IP=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/interface[./@name="'"$TYPE_INTERFACE"'"]/default_ip['$TYPE_INTERFACE_DEFAULT_IP_INDEX'])' $XML_FILE)
        done

        ((TYPE_INTERFACE_INDEX++))
        TYPE_INTERFACE=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/interface['$TYPE_INTERFACE_INDEX']/@name)' $XML_FILE)
      done

      # ptoribi: READ THE COPY COMMANDS FOR THAT TYPE
      TYPE_COPY_INDEX=1
      TYPE_COPY_SOURCE=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/copy/artifact['$TYPE_COPY_INDEX']/@source)' $XML_FILE)
      TYPE_COPY_DESTINATION=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/copy/artifact['$TYPE_COPY_INDEX']/@destination)' $XML_FILE)
      while [[ ${#TYPE_COPY_SOURCE} -ne 0 && ${#TYPE_COPY_DESTINATION} -ne 0 ]]
      do
        eval XML_${TYPE}_copy${TYPE_COPY_INDEX}_source=$TYPE_COPY_SOURCE
        eval XML_${TYPE}_copy${TYPE_COPY_INDEX}_destination=$TYPE_COPY_DESTINATION

        ((TYPE_COPY_INDEX++))
        TYPE_COPY_SOURCE=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/copy/artifact['$TYPE_COPY_INDEX']/@source)' $XML_FILE)
        TYPE_COPY_DESTINATION=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/copy/artifact['$TYPE_COPY_INDEX']/@destination)' $XML_FILE)
      done

      # ptoribi: READ THE SETUP CONFIGURATION COMMANDS FOR THAT TYPE
      TYPE_SETUP_INDEX=1
      TYPE_SETUP=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/setup/command['$TYPE_SETUP_INDEX'])' $XML_FILE)
      while [[ ${#TYPE_SETUP} -ne 0 ]]
      do
        eval XML_${TYPE}_setup${TYPE_SETUP_INDEX}=$TYPE_SETUP

        ((TYPE_SETUP_INDEX++))
        TYPE_SETUP=$(xmllint --xpath 'string(/scenario/type[./@name="'"$TYPE"'"]/setup/command['$TYPE_SETUP_INDEX'])' $XML_FILE)
      done

      ((TYPE_INDEX++))
      TYPE=$(xmllint --xpath 'string(/scenario/type['$TYPE_INDEX']/@name)' $XML_FILE)
    done
}

# usage: read_networks XML_FILE
# description: reads an XML scenario file and creates containers, networks and connections accordingly
# example: read_networks /usr/local/lightning/scenarios/RYSCA/simple_con_router.xml
read_networks() {

  local XML_FILE=$1

  # ptoribi: variables and indexes for reading the XML file
  local NETWORK_INDEX=1
  local NETWORK_CONTAINER_INDEX=1
  local NETWORK_CONTAINER_INTERFACE_INDEX=1
  local NETWORK_CONTAINER_INTERFACE_IP_INDEX=1

  local NETWORK
  local NETWORK_type

  local NETWORK_CONTAINER
  local NETWORK_CONTAINER_hostname
  local NETWORK_CONTAINER_type

  local NETWORK_CONTAINER_IP

    # 1. CREATE NETWORK
    NETWORK_INDEX=1
    NETWORK=$(xmllint --xpath 'string(/scenario/network['$NETWORK_INDEX']/@name)' $XML_FILE)
    while [[ ${#NETWORK} -ne 0 ]]
    do
      NETWORK_type=$(xmllint --xpath 'string(/scenario/network['$NETWORK_INDEX']/@type)' $XML_FILE)

      create_network $NETWORK $NETWORK_type

      # 2.- CREATE CONTAINER
      NETWORK_CONTAINER_INDEX=1
      NETWORK_CONTAINER=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container['$NETWORK_CONTAINER_INDEX']/@name)' $XML_FILE)
      while [[ ${#NETWORK_CONTAINER} -ne 0 ]]
      do
        NETWORK_CONTAINER_hostname=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container['$NETWORK_CONTAINER_INDEX']/@hostname)' $XML_FILE)
        if [[ ${#NETWORK_CONTAINER_hostname} -eq 0 ]]; then NETWORK_CONTAINER_hostname=$NETWORK_CONTAINER; fi # ptoribi: if hostname not specified, hostname=name
        NETWORK_CONTAINER_type=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container['$NETWORK_CONTAINER_INDEX']/@type)' $XML_FILE)

        check_if_container_already_created $NETWORK_CONTAINER
        if [[ "$container_already_created" == "no" ]]
        then
          create_container $NETWORK_CONTAINER $NETWORK_CONTAINER_hostname $NETWORK_CONTAINER_type
        fi

        # 3.- CONNECT INTERFACE TO THE NETWORK
        NETWORK_CONTAINER_INTERFACE_INDEX=1
        NETWORK_CONTAINER_INTERFACE=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container[./@name="'"$NETWORK_CONTAINER"'"]/interface['$NETWORK_CONTAINER_INTERFACE_INDEX']/@name)' $XML_FILE)
        while [[ ${#NETWORK_CONTAINER_INTERFACE} -ne 0 ]]
        do
          connect_machine $NETWORK_CONTAINER $NETWORK_CONTAINER_INTERFACE $NETWORK

          # 4.- CONFIGURE IP IN THE INTERFACE
          NETWORK_CONTAINER_INTERFACE_IP_INDEX=1
          NETWORK_CONTAINER_INTERFACE_IP=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container[./@name="'"$NETWORK_CONTAINER"'"]/interface[./@name="'"$NETWORK_CONTAINER_INTERFACE"'"]/ip['$NETWORK_CONTAINER_INTERFACE_IP_INDEX'])' $XML_FILE)
          while [[ ${#NETWORK_CONTAINER_INTERFACE_IP} -ne 0 ]]
          do
            configure_ip $NETWORK_CONTAINER $NETWORK_CONTAINER_INTERFACE $NETWORK_CONTAINER_INTERFACE_IP

            ((NETWORK_CONTAINER_INTERFACE_IP_INDEX++))
            NETWORK_CONTAINER_INTERFACE_IP=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container[./@name="'"$NETWORK_CONTAINER"'"]/interface[./@name="'"$NETWORK_CONTAINER_INTERFACE"'"]/ip['$NETWORK_CONTAINER_INTERFACE_IP_INDEX'])' $XML_FILE)
          done

          ((NETWORK_CONTAINER_INTERFACE_INDEX++))
          NETWORK_CONTAINER_INTERFACE=$(xmllint --xpath 'string(/scenario/container[./@name="'"$CONTAINER"'"]/interface['$NETWORK_CONTAINER_INTERFACE_INDEX']/@name)' $XML_FILE)
        done

        ((NETWORK_CONTAINER_INDEX++))
        NETWORK_CONTAINER=$(xmllint --xpath 'string(/scenario/network[./@name="'"$NETWORK"'"]/container['$NETWORK_CONTAINER_INDEX']/@name)' $XML_FILE)
      done

      ((NETWORK_INDEX++))
      NETWORK=$(xmllint --xpath 'string(/scenario/network['$NETWORK_INDEX']/@name)' $XML_FILE)
    done
}
